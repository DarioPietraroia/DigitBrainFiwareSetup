{
	"info": {
		"_postman_id": "9502056b-5503-471b-b491-c4af03a10450",
		"name": "DigitBrain fiware suite collection",
		"description": "This tutorial uses introduces the use of the MQTT protocol across IoT devices connecting to FIWARE. The [UltraLight 2.0](http://fiware-iotagent-ul.readthedocs.io/en/latest/usermanual/index.html#user-programmers-manual) IoT Agent\ncreated in the [previous tutorial](https://github.com/Fiware/tutorials.IoT-Agent) is reconfigured to\ncommunicate with a set of dummy IoT devices using MQTT\n\n# What is MQTT?\n\nMQTT is publish-subscribe-based messaging protocol used in the Internet of Things. It works on top of the TCP/IP\nprotocol, and is designed for connections with remote locations where a \"small code footprint\" is required or the\nnetwork bandwidth is limited. The goal is to provide a protocol, which is bandwidth-efficient and uses little\nbattery power.\n\nThe [previous tutorial](https://github.com/Fiware/tutorials.IoT-Agent) used HTTP as its transport mechanism between\nthe devices and the IoT Agent. HTTP uses a request/response paradigm where each device connects directly to the IoT Agent.\nMQTT is different in that publish-subscribe is event-driven and pushes messages to clients. It requires an additional\ncentral communication point (known as the MQTT broker) which it is in charge of dispatching all messages between the senders and the rightful receivers. Each client that publishes a message to the broker, includes a **topic** into the message. The **topic** is the routing information for the broker. Each client that wants to receive messages subscribes to a certain **topic** and the broker delivers all messages with the matching **topic** to the client. Therefore the clients don’t have to know each other, they only communicate over the **topic**. This architecture enables highly scalable solutions without dependencies between the data producers and the data consumers.\n\n\nThe UltraLight 2.0 IoT Agent will only send or interpret messages using the [UltraLight 2.0](http://fiware-iotagent-ul.readthedocs.io/en/latest/usermanual/index.html#user-programmers-manual) syntax,\nhowever it can be used to send and receive messages over multiple **transport** mechanisms. Therefore we\nare able to use the same FIWARE generic enabler to connect to a wider range of IoT devices.\n\n#### Mosquitto MQTT Broker\n\n[Mosquitto](https://mosquitto.org/) is a readily available, open source MQTT broker which will be used during this tutorial.\nIt is available licensed under EPL/EDL. More information can be found at https://mosquitto.org/\n\n\n#### Device Monitor\n\nFor the purpose of this tutorial, a series of dummy IoT devices have been created, which will be attached to the context broker. Details of the architecture and protocol used can be found in the [IoT Sensors tutorial](https://github.com/Fiware/tutorials.IoT-Sensors)\nThe state of each device can be seen on the UltraLight device monitor web-page found at: `http://localhost:3000/device/monitor`\n\n![FIWARE Monitor](https://fiware.github.io/tutorials.IoT-over-MQTT/img/device-monitor.png)\n\n# Architecture\n\nThis application builds on the components created in [previous tutorials](https://github.com/Fiware/tutorials.IoT-Agent/). It\nwill make use of two FIWARE components - the [Orion Context Broker](https://fiware-orion.readthedocs.io/en/latest/) and the [IoT Agent for UltraLight 2.0](http://fiware-iotagent-ul.readthedocs.io/en/latest/). Usage of the Orion Context Broker is sufficient for an application to qualify as *“Powered by FIWARE”*.\nBoth the Orion Context Broker and the IoT Agent rely on open source [MongoDB](https://www.mongodb.com/) technology to keep persistence of the information they hold. We will also be using the dummy IoT devices created in the [previous tutorial](https://github.com/Fiware/tutorials.IoT-Agent/) \nAdditionally will add an instance of the [Mosquitto](https://mosquitto.org/) MQTT broker which is open source and available under the EPL/EDL.\n\n\nTherefore the overall architecture will consist of the following elements:\n\n* The FIWARE [Orion Context Broker](https://fiware-orion.readthedocs.io/en/latest/) which will receive requests using [NGSI](https://fiware.github.io/specifications/OpenAPI/ngsiv2)\n* The FIWARE [IoT Agent for UltraLight 2.0](http://fiware-iotagent-ul.readthedocs.io/en/latest/) which will:\n + receive southbound requests using [NGSI](https://fiware.github.io/specifications/OpenAPI/ngsiv2) and convert them to  [UltraLight 2.0](http://fiware-iotagent-ul.readthedocs.io/en/latest/usermanual/index.html#user-programmers-manual) MQTT topics for the MQTT Broker\n + listen to the **MQTT Broker** on registered topics to send measurements northbound\n* The [Mosquitto](https://mosquitto.org/) **MQTT Broker** which acts as a central communication point, passing \n  MQTT topics between the **IoT Agent** and IoT devices as necessary.\n* The underlying [MongoDB](https://www.mongodb.com/) database :\n  + Used by the **Orion Context Broker** to hold context data information such as data entities, subscriptions and registrations\n  + Used by the **IoT Agent** to hold device information such as device URLs and Keys\n* A webserver acting as set of [dummy IoT devices](https://github.com/Fiware/tutorials.IoT-Sensors) using the [UltraLight 2.0](http://fiware-iotagent-ul.readthedocs.io/en/latest/usermanual/index.html#user-programmers-manual) protocol running over MQTT.\n* The **Context Provider NGSI** proxy is not used in this tutorial. It does the following:\n  + receive requests using [NGSI](https://fiware.github.io/specifications/OpenAPI/ngsiv2)\n  + makes requests to publicly available data sources using their own APIs in a proprietary format \n  + returns context data back to the Orion Context Broker in [NGSI](https://fiware.github.io/specifications/OpenAPI/ngsiv2) format.\n* The **Stock Management Frontend**  is not used in this tutorial will it does the following:\n  + Display store information\n  + Show which products can be bought at each store\n  + Allow users to \"buy\" products and reduce the stock count.\n\n\nSince all interactions between the elements are initiated by HTTP or MQTT requests over TCP, the entities can be containerized and run from exposed ports. \n\n![](https://fiware.github.io/tutorials.IoT-over-MQTT/img/architecture.png)\n\nThe necessary configuration information for wiring up the Mosquitto MQTT Broker, the IoT devices and the IoT Agent can be seen in the services section of the associated `docker-compose.yml`  file:\n\n## Mosquitto Configuration\n\n```yaml\n  mosquitto:\n    image: eclipse-mosquitto\n    hostname: mosquitto\n    container_name: mosquitto\n    networks:\n        - default\n    expose:\n        - \"1883\"\n        - \"9001\"\n    ports:\n        - \"1883:1883\"\n        - \"9001:9001\"\n    volumes:\n      - ./mosquitto/mosquitto.conf:/mosquitto/config/mosquitto.conf\n    \n```\n\nThe `mosquitto` container is listening on two ports: \n\n* Port `3000` is exposed so we can post MQTT topics\n* Port `9001` is the standard port for HTTP/Websocket communications\n\nThe attached volume is a [configuration file](https://github.com/Fiware/tutorials.IoT-over-MQTT/blob/master/osquitto/mosquitto.conf) used to increase the debug level of the MQTT Message Broker.\n\n## Dummy IoT Devices Configuration\n\n```yaml\n  context-provider:\n    image: fiware/cp-web-app:latest\n    hostname: context-provider\n    container_name: context-provider\n    networks:\n        - default\n    expose:\n        - \"3000\"\n        - \"3001\"\n    ports:\n        - \"3000:3000\"\n        - \"3001:3001\"\n    environment:\n        - \"DEBUG=proxy:*\"\n        - \"PORT=3000\"\n        - \"DUMMY_DEVICES_PORT=3001\"\n        - \"DUMMY_DEVICES_API_KEY=4jggokgpepnvsb2uv4s40d59ov\"\n        - \"DUMMY_DEVICES_TRANSPORT=MQTT\"\n```\n\nThe `context-provider` container is listening on two ports: \n\n* Port `3000` is exposed so we can see the web-page displaying the Dummy IoT devices.\n* Port `3001` is exposed purely for tutorial access - so that cUrl or Postman can make UltraLight commands\n  without being part of the same network.\n\n\nThe `context-provider` container is driven by environment variables as shown:\n\n| Key |Value|Description|\n|-----|-----|-----------|\n|DEBUG|`proxy:*`| Debug flag used for logging |\n|PORT|`3000`|Port used by web-app which displays the dummy device data |\n|DUMMY_DEVICES_PORT|`3001`|Port used by the dummy IoT devices to receive commands |\n|DUMMY_DEVICES_API_KEY|`4jggokgpepnvsb2uv4s40d59ov`| Random security key used for UltraLight interactions - used to ensure the integrity of interactions between the devices and the IoT Agent |\n\nThe other `context-provider` container configuration values described in the YAML file are not used in this tutorial.\n\n## IoT Agent for UltraLight 2.0 Configuration\n\nThe [IoT Agent for UltraLight 2.0](http://fiware-iotagent-ul.readthedocs.io/en/latest/)  can be instantiated within a Docker container. An official Docker image is available from [Docker Hub](https://hub.docker.com/r/fiware/iotagent-ul/) tagged `fiware/iotagent-ul`. The \nnecessary configuration can be seen below:\n\n```yaml\n  iot-agent:\n    image: fiware/iotagent-ul:latest\n    hostname: iot-agent\n    container_name: fiware-iot-agent\n    depends_on:\n      - mongo-db\n    networks:\n        - default\n    expose:\n        - \"4041\"\n        - \"7896\"\n    ports:\n        - \"4041:4041\"\n        - \"7896:7896\"\n    environment:\n        - \"IOTA_CB_HOST=orion\"\n        - \"IOTA_CB_PORT=1026\"\n        - \"IOTA_NORTH_PORT=4041\"\n        - \"IOTA_REGISTRY_TYPE=mongodb\"\n        - \"IOTA_LOG_LEVEL=DEBUG\"\n        - \"IOTA_TIMESTAMP=true\"\n        - \"IOTA_MONGO_HOST=mongo-db\"\n        - \"IOTA_MONGO_PORT=27017\"\n        - \"IOTA_MONGO_DB=iotagentul\"\n        - \"IOTA_PROVIDER_URL=http://iot-agent:4041\"\n        - \"IOTA_MQTT_HOST=mosquitto\"\n        - \"IOTA_MQTT_PORT=1883\"\n```\n\nThe `iot-agent` container relies on the precence of the Orion Context Broker and uses a MongoDB database to hold device information such as device URLs and Keys. The container is listening on two ports: \n\n* Port `7896` is exposed to receive Ultralight measurements over HTTP from the Dummy IoT devices\n* Port `4041` is exposed purely for tutorial access - so that cUrl or Postman can make provisioning commands\n  without being part of the same network.\n\n\nThe `iot-agent` container is driven by environment variables as shown:\n\n| Key |Value|Description|\n|-----|-----|-----------|\n|IOTA_CB_HOST|`orion`| Hostname of the context broker to update context |\n|IOTA_CB_PORT|`1026`| Port that context broker listens on to update context |\n|IOTA_NORTH_PORT|`4041` | Port used for Configuring the IoT Agent and receiving context updates from the context broker |\n|IOTA_REGISTRY_TYPE|`mongodb`| Whether to hold IoT device info in memory or in a database |\n|IOTA_LOG_LEVEL|`DEBUG`|The log level of the IoT Agent |\n|IOTA_TIMESTAMP|`true`| Whether to supply timestamp information with each measurement received from attached devices |\n|IOTA_MONGO_HOST|`context-db`| The host name of mongoDB - used for holding device information |\n|IOTA_MONGO_PORT|`27017`| The port mongoDB is listening on |\n|IOTA_MONGO_DB|`iotagentul`| The name of the database used in mongoDB |\n|IOTA_PROVIDER_URL|`http://iot-agent:4041`| URL passed to the Context Broker when commands are registered, used as a forwarding URL location when the Context Broker issues a command to a device | \n|IOTA_MQTT_HOST|`mosquitto`| The host name of the MQTT Broker  |\n|IOTA_MQTT_PORT|`1883`| The port the MQTT Broker is listening on to receive topics |\n\nAs you can see, use of the MQTT transport is driven by only two environment variables `IOTA_MQTT_HOST` and `IOTA_MQTT_PORT`\n\n# Prerequisites\n\n## Docker and Docker Compose \n\nTo keep things simple all components will be run using [Docker](https://www.docker.com). **Docker** is a container technology which allows to different components isolated into their respective environments. \n\n* To install Docker on Windows follow the instructions [here](https://docs.docker.com/docker-for-windows/)\n* To install Docker on Mac follow the instructions [here](https://docs.docker.com/docker-for-mac/)\n* To install Docker on Linux follow the instructions [here](https://docs.docker.com/install/)\n\n**Docker Compose** is a tool for defining and running multi-container Docker applications. A \n[YAML file](https://raw.githubusercontent.com/Fiware/tutorials.IoT-over-MQTT/master/docker-compose.yml) is used\nconfigure the required services for the application. This means all container services can be brought up in a single \ncommand. Docker Compose is installed by default  as part of Docker for Windows and  Docker for Mac, however Linux users \nwill need to follow the instructions found  [here](https://docs.docker.com/compose/install/)\n## Cygwin for Windows\n\nWe will start up our services using a simple Bash script. Windows users should download [cygwin](http://www.cygwin.com/) to provide a command line functionality similar to a Linux distribution on Windows.\n\n\n# Start Up\n\nBefore you start you should ensure that you have obtained or built the necessary Docker images locally. Please clone the repository and create the necessary images by running the commands as shown:\n\n```console\ngit clone git@github.com:Fiware/tutorials.IoT-over-MQTT.git\ncd tutorials.IoT-over-MQTT\n\n./services create\n``` \n\n>**Note** The `context-provider` image has not yet been pushed to Docker hub.\n> Failing to build the Docker sources before proceeding will result in the following error:\n>\n>```\n>Pulling context-provider (fiware/cp-web-app:latest)...\n>ERROR: The image for the service you're trying to recreate has been removed.\n>```\n\n\nThereafter, all services can be initialized from the command line by running the [services](https://github.com/Fiware/tutorials.IoT-over-MQTT/blob/master/services) Bash script provided within the repository:\n\n```console\n./services start\n``` \n\n>:information_source: **Note:** If you want to clean up and start over again you can do so with the following command:\n>\n>```console\n>./services stop\n>``` \n>\n\n\n\n",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "UNSECURE DigitBrain data model CRUD operations",
			"item": [
				{
					"name": "Create facility",
					"protocolProfileBehavior": {
						"disabledSystemHeaders": {
							"content-type": true
						}
					},
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"actionType\": \"APPEND\",\n  \"entities\": [\n    {\n      \"type\": \"Facility\",\n      \"id\": \"urn:ngsi-ld:Facility:003\",\n      \"address\": {\n        \"type\": \"PostalAddress\",\n        \"value\": {\n            \"streetAddress\": \"Bornholmer Straße 65\",\n            \"addressRegion\": \"Berlin\",\n            \"addressLocality\": \"Prenzlauer Berg\",\n            \"postalCode\": \"10439\"\n          }\n      },\n      \"location\": {\n          \"type\": \"geo:json\",\n          \"value\": {\n             \"type\": \"Point\",\n             \"coordinates\": [13.3986, 52.5547]\n          }\n      },\n      \"name\": {\n          \"type\": \"Text\",\n          \"value\": \"Bösebrücke Einkauf\"\n      }\n    }\n  ]\n}"
						},
						"url": {
							"raw": "http://{{orion}}/v2/op/update",
							"protocol": "http",
							"host": [
								"{{orion}}"
							],
							"path": [
								"v2",
								"op",
								"update"
							],
							"query": [
								{
									"key": "faciltyId",
									"value": "002",
									"disabled": true
								}
							]
						},
						"description": "This example uses the convenience batch processing endpoint to re-create the two **Store** entities from the previous tutorial.\n\nBatch processing uses the `/v2/op/update` endpoint with a payload with two attributes - `actionType=APPEND` means we will overwrite existing entities if they exist whereas the  `entities` attribute holds an array of entities we wish to update.\n\nAs you can see each **Store** entity in the payload has been given a unique `id` (according to the NGSI-LD [specification](https://www.etsi.org/deliver/etsi_gs/CIM/001_099/009/01.03.01_60/gs_cim009v010301p.pdf)) and assigned `type=Store`."
					},
					"response": []
				},
				{
					"name": "Create Industrial product",
					"protocolProfileBehavior": {
						"disabledSystemHeaders": {
							"content-type": true
						}
					},
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"actionType\": \"APPEND\",\n  \"entities\": [\n    {\n      \"type\": \"IndustrialProduct\",\n      \"id\": \"urn:ngsi-ld:IndustrialProduct:001\",\n      \"name\": {\n          \"type\": \"Text\",\n          \"value\": \"Industrial product name\"\n      }\n    ,\n        \"refFacility\": {\n            \"type\": \"Relationship\",\n            \"value\": \"urn:ngsi-ld:Facility:001\",\n            \"metadata\": {}\n        }\n    }\n  ]\n}"
						},
						"url": {
							"raw": "http://{{orion}}/v2/op/update",
							"protocol": "http",
							"host": [
								"{{orion}}"
							],
							"path": [
								"v2",
								"op",
								"update"
							],
							"query": [
								{
									"key": "faciltyId",
									"value": "002",
									"disabled": true
								}
							]
						},
						"description": "This example uses the convenience batch processing endpoint to re-create the two **Store** entities from the previous tutorial.\n\nBatch processing uses the `/v2/op/update` endpoint with a payload with two attributes - `actionType=APPEND` means we will overwrite existing entities if they exist whereas the  `entities` attribute holds an array of entities we wish to update.\n\nAs you can see each **Store** entity in the payload has been given a unique `id` (according to the NGSI-LD [specification](https://www.etsi.org/deliver/etsi_gs/CIM/001_099/009/01.03.01_60/gs_cim009v010301p.pdf)) and assigned `type=Store`."
					},
					"response": []
				},
				{
					"name": "List all entities",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "http://{{orion}}/v2/entities",
							"protocol": "http",
							"host": [
								"{{orion}}"
							],
							"path": [
								"v2",
								"entities"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Authentication and security",
			"item": [
				{
					"name": "Keyrock- Authentication and tokend",
					"item": [
						{
							"name": "Create Keyrock token with Password",
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Accept",
										"value": "application/json",
										"disabled": true
									},
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"name\": \"pietraroia@ttsnetwork.com\",\n  \"password\": \"1234\"\n}"
								},
								"url": {
									"raw": "http://{{keyrock}}/v1/auth/tokens",
									"protocol": "http",
									"host": [
										"{{keyrock}}"
									],
									"path": [
										"v1",
										"auth",
										"tokens"
									]
								},
								"description": "The following example logs in using the Admin Super-User - it is the equivalent of using the log-in screen of the GUI.\nThe URL `https://localhost:3443/v1/auth/tokens` should also work in a secure system.\n\nThe response header returns an `X-Subject-token` which identifies who has logged on the application.\nThis token is required in all subsequent requests to gain access."
							},
							"response": []
						},
						{
							"name": "Get User Information via a Token",
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Accept",
										"value": "application/json",
										"disabled": true
									},
									{
										"key": "Content-Type",
										"value": "application/json"
									},
									{
										"key": "X-Auth-token",
										"value": "{{X-Auth-token}}"
									},
									{
										"key": "X-Subject-token",
										"value": "{{X-Subject-token}}"
									}
								],
								"url": {
									"raw": "http://{{keyrock}}/v1/auth/tokens",
									"protocol": "http",
									"host": [
										"{{keyrock}}"
									],
									"path": [
										"v1",
										"auth",
										"tokens"
									]
								},
								"description": "In order to manage the Identity Manager through the API you must obtain an access token to be included in HTTP headers. There are two methods to obtain an access token."
							},
							"response": []
						},
						{
							"name": "Keyrock - User Obtains an Access Token",
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Authorization",
										"value": "Basic {{Authorization}}",
										"description": "base64 concatenation of Client Id and Client Secret"
									},
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded"
									},
									{
										"key": "Accept",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "username=pietraroia@ttsnetwork.com&password=1234&grant_type=password&scope=permanent"
								},
								"url": {
									"raw": "http://{{keyrock}}/oauth2/token",
									"protocol": "http",
									"host": [
										"{{keyrock}}"
									],
									"path": [
										"oauth2",
										"token"
									]
								},
								"description": "To log in to an application using the user-credentials flow send a POST request to the `oauth2/token` endpoint with the `grant_type=password`\n\nThe response returns an `access_code` to identify the user.\n\nAn `access_code` can also be done by entering the Tutorial Application on http:/localhost and logging in using any of the OAuth2 grants\non the page. A successful log-in will return an access token."
							},
							"response": []
						},
						{
							"name": "list apps",
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Accept",
										"value": "application/json",
										"disabled": true
									},
									{
										"key": "Content-Type",
										"value": "application/json",
										"disabled": true
									},
									{
										"key": "X-Auth-token",
										"value": "{{X-Auth-token}}"
									}
								],
								"url": {
									"raw": "http://{{keyrock}}/v1/applications/",
									"protocol": "http",
									"host": [
										"{{keyrock}}"
									],
									"path": [
										"v1",
										"applications",
										""
									]
								},
								"description": "Making a GET request the `/v1/applications/{{application-id}}/pep_proxies/` endpoint will return the details of the associated PEP Proxy Account. The `X-Auth-token` must be supplied in the headers."
							},
							"response": []
						}
					]
				},
				{
					"name": "PEP Proxy CRUD Actions",
					"item": [
						{
							"name": "Create a PEP Proxy",
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Accept",
										"value": "application/json"
									},
									{
										"key": "Content-Type",
										"value": "application/json"
									},
									{
										"key": "X-Auth-token",
										"value": "{{X-Auth-token}}"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"pep_proxy\": {\r\n        \"id\": \"testid\",\r\n        \"password\": \"test_password\"\r\n    }\r\n}"
								},
								"url": {
									"raw": "http://{{keyrock}}/v1/applications/{{application-id}}/pep_proxies",
									"protocol": "http",
									"host": [
										"{{keyrock}}"
									],
									"path": [
										"v1",
										"applications",
										"{{application-id}}",
										"pep_proxies"
									]
								},
								"description": "To create a new PEP Proxy account within an application , send a POST request to the `//v1/applications/{{application-id}}/pep_proxies` endpoint  along with the `X-Auth-token` header from a previously logged in administrative user.\n\nProvided there is no previously existing PEP Proxy account associated with the application, a new account will be created with a unique `id` and `password` and the values will be returned in the response."
							},
							"response": []
						},
						{
							"name": "Read PEP Proxy Details",
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Accept",
										"value": "application/json",
										"disabled": true
									},
									{
										"key": "Content-Type",
										"value": "application/json",
										"disabled": true
									},
									{
										"key": "X-Auth-token",
										"value": "{{X-Auth-token}}"
									}
								],
								"url": {
									"raw": "http://{{keyrock}}/v1/applications/{{application-id}}/pep_proxies/",
									"protocol": "http",
									"host": [
										"{{keyrock}}"
									],
									"path": [
										"v1",
										"applications",
										"{{application-id}}",
										"pep_proxies",
										""
									]
								},
								"description": "Making a GET request the `/v1/applications/{{application-id}}/pep_proxies/` endpoint will return the details of the associated PEP Proxy Account. The `X-Auth-token` must be supplied in the headers."
							},
							"response": []
						},
						{
							"name": "Reset Password of PEP Proxy",
							"request": {
								"method": "PATCH",
								"header": [
									{
										"key": "Accept",
										"value": "application/json",
										"disabled": true
									},
									{
										"key": "Content-Type",
										"value": "application/json"
									},
									{
										"key": "X-Auth-token",
										"value": "{{X-Auth-token}}"
									}
								],
								"body": {
									"mode": "raw",
									"raw": ""
								},
								"url": {
									"raw": "http://{{keyrock}}/v1/applications/{{application-id}}/pep_proxies",
									"protocol": "http",
									"host": [
										"{{keyrock}}"
									],
									"path": [
										"v1",
										"applications",
										"{{application-id}}",
										"pep_proxies"
									]
								},
								"description": "To renew the password of a PEP Proxy Account, make a PATCH request to the  `/v1/applications/{{application-id}}/pep_proxies` endpoint will return the details of the associated PEP Proxy Account. The `X-Auth-token` must be supplied in the headers.\n\nThe response returns a new password."
							},
							"response": []
						},
						{
							"name": "Delete PEP Proxy",
							"request": {
								"method": "DELETE",
								"header": [
									{
										"key": "Accept",
										"value": "application/json"
									},
									{
										"key": "Content-Type",
										"value": "application/json"
									},
									{
										"key": "X-Auth-token",
										"value": "{{X-Auth-token}}"
									}
								],
								"body": {
									"mode": "formdata",
									"formdata": []
								},
								"url": {
									"raw": "http://{{keyrock}}/v1/applications/{{application-id}}/pep_proxies",
									"protocol": "http",
									"host": [
										"{{keyrock}}"
									],
									"path": [
										"v1",
										"applications",
										"{{application-id}}",
										"pep_proxies"
									]
								},
								"description": "An existing PEP Proxy Account can be deleted by making a DELETE request to the  `/v1/applications/{{application-id}}/pep_proxies` endpoint. The `X-Auth-token` must be supplied in the headers."
							},
							"response": []
						}
					],
					"description": "#### GUI\n\nOnce signed-in, users are able to create and update PEP Proxies associated to their applications for themselves.\n\n![](https://fiware.github.io/tutorials.PEP-Proxy/img/create-pep-proxy.png)\n\n#### REST API\n\nAlternatively, the standard CRUD actions are assigned to the appropriate HTTP verbs (POST, GET, PATCH and DELETE) under the `/v1/applications/{{application-id}}/pep_proxies` endpoint.\n",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						}
					]
				},
				{
					"name": "IoT Agent  security CRUD Actions",
					"item": [
						{
							"name": "Create an IoT Agent in Keyrock",
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Accept",
										"value": "application/json"
									},
									{
										"key": "Content-Type",
										"value": "application/json"
									},
									{
										"key": "X-Auth-token",
										"value": "{{X-Auth-token}}"
									}
								],
								"body": {
									"mode": "formdata",
									"formdata": []
								},
								"url": {
									"raw": "http://{{keyrock}}/v1/applications/{{application-id}}/iot_agents",
									"protocol": "http",
									"host": [
										"{{keyrock}}"
									],
									"path": [
										"v1",
										"applications",
										"{{application-id}}",
										"iot_agents"
									]
								},
								"description": "To create a new IoT Agent account within an application, send a POST request to the `/v1/applications/{{application-id}}/iot_agents` endpoint  along with the `X-Auth-token` header from a previously logged in administrative user.\n\nA new account will be created with a unique `id` and `password` and the values will be returned in the response."
							},
							"response": []
						},
						{
							"name": "Read IoT Agent details",
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Accept",
										"value": "application/json"
									},
									{
										"key": "Content-Type",
										"value": "application/json"
									},
									{
										"key": "X-Auth-token",
										"value": "{{X-Auth-token}}"
									}
								],
								"url": {
									"raw": "http://{{keyrock}}/v1/applications/{{application-id}}/iot_agents/{{iot-agent-id}}",
									"protocol": "http",
									"host": [
										"{{keyrock}}"
									],
									"path": [
										"v1",
										"applications",
										"{{application-id}}",
										"iot_agents",
										"{{iot-agent-id}}"
									]
								},
								"description": "Making a GET request the `/v1/applications/{{application-id}}/iot_agents/{{iot-agent-id}}` endpoint will return the details of the associated IoT Agent Account. The `X-Auth-token` must be supplied in the headers."
							},
							"response": []
						},
						{
							"name": "List of IoT Agents",
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Accept",
										"value": "application/json"
									},
									{
										"key": "Content-Type",
										"value": "application/json"
									},
									{
										"key": "X-Auth-token",
										"value": "{{X-Auth-token}}"
									}
								],
								"url": {
									"raw": "http://{{keyrock}}/v1/applications/{{application-id}}/iot_agents",
									"protocol": "http",
									"host": [
										"{{keyrock}}"
									],
									"path": [
										"v1",
										"applications",
										"{{application-id}}",
										"iot_agents"
									]
								},
								"description": "A list of all IoT Agents associated with an application can be obtained by making a GET request the `/v1/applications/{{application-id}}/iot_agents` endpoint. The `X-Auth-token` must be supplied in the headers."
							},
							"response": []
						},
						{
							"name": "Reset Password of IoT Agent",
							"request": {
								"method": "PATCH",
								"header": [
									{
										"key": "Accept",
										"value": "application/json",
										"disabled": true
									},
									{
										"key": "Content-Type",
										"value": "application/json"
									},
									{
										"key": "X-Auth-token",
										"value": "{{X-Auth-token}}"
									}
								],
								"body": {
									"mode": "formdata",
									"formdata": []
								},
								"url": {
									"raw": "http://{{keyrock}}/v1/applications/{{application-id}}/iot_agents/{{iot-agent-id}}",
									"protocol": "http",
									"host": [
										"{{keyrock}}"
									],
									"path": [
										"v1",
										"applications",
										"{{application-id}}",
										"iot_agents",
										"{{iot-agent-id}}"
									]
								},
								"description": "To renew the password of an individual IoT Agent Account, make a PATCH request to the  `/v1/applications/{{application-id}}//iot_agents/{{iot-agent-id}}` endpoint. \nThe `X-Auth-token` must be supplied in the headers.\n\nThe response returns a new password."
							},
							"response": []
						},
						{
							"name": "Delete an IoT Agent",
							"request": {
								"method": "DELETE",
								"header": [
									{
										"key": "Accept",
										"value": "application/json",
										"disabled": true
									},
									{
										"key": "Content-Type",
										"value": "application/json"
									},
									{
										"key": "X-Auth-token",
										"value": "{{X-Auth-token}}"
									}
								],
								"body": {
									"mode": "formdata",
									"formdata": []
								},
								"url": {
									"raw": "http://{{keyrock}}/v1/applications/{{application-id}}/iot_agents/{{iot-agent-id}}",
									"protocol": "http",
									"host": [
										"{{keyrock}}"
									],
									"path": [
										"v1",
										"applications",
										"{{application-id}}",
										"iot_agents",
										"{{iot-agent-id}}"
									]
								},
								"description": "An existing IoT Agent Account can be deleted by making a DELETE request to the  `/v1/applications/{{application-id}}/iot_agents/{{iot-agent-id}}` endpoint. \nThe `X-Auth-token` must be supplied in the headers."
							},
							"response": []
						}
					],
					"description": "#### GUI\n\nIn a similar manner to PEP Proxy creation, signed-in, users are able to create and update IoT Sensor Accounts associated to their \napplications.\n\n![](https://fiware.github.io/tutorials.PEP-Proxy/img/create-iot-sensor.png)\n\n#### REST API\n\nAlternatively, the standard CRUD actions are assigned to the ",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						}
					]
				}
			]
		},
		{
			"name": "DigitBrain data model CRUD operations",
			"item": [
				{
					"name": "Create facility",
					"protocolProfileBehavior": {
						"disabledSystemHeaders": {
							"content-type": true
						}
					},
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X",
								"value": "",
								"type": "default"
							},
							{
								"key": "X-Auth-token",
								"value": "{{X-Access-token}}",
								"type": "default"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"actionType\": \"APPEND\",\n  \"entities\": [\n    {\n      \"type\": \"Facility\",\n      \"id\": \"urn:ngsi-ld:Facility:003\",\n      \"address\": {\n        \"type\": \"PostalAddress\",\n        \"value\": {\n            \"streetAddress\": \"Bornholmer Straße 65\",\n            \"addressRegion\": \"Berlin\",\n            \"addressLocality\": \"Prenzlauer Berg\",\n            \"postalCode\": \"10439\"\n          }\n      },\n      \"location\": {\n          \"type\": \"geo:json\",\n          \"value\": {\n             \"type\": \"Point\",\n             \"coordinates\": [13.3986, 52.5547]\n          }\n      },\n      \"name\": {\n          \"type\": \"Text\",\n          \"value\": \"Bösebrücke Einkauf\"\n      }\n    }\n  ]\n}"
						},
						"url": {
							"raw": "http://{{orion-proxy}}/v2/op/update",
							"protocol": "http",
							"host": [
								"{{orion-proxy}}"
							],
							"path": [
								"v2",
								"op",
								"update"
							],
							"query": [
								{
									"key": "faciltyId",
									"value": "002",
									"disabled": true
								}
							]
						},
						"description": "This example uses the convenience batch processing endpoint to re-create the two **Store** entities from the previous tutorial.\n\nBatch processing uses the `/v2/op/update` endpoint with a payload with two attributes - `actionType=APPEND` means we will overwrite existing entities if they exist whereas the  `entities` attribute holds an array of entities we wish to update.\n\nAs you can see each **Store** entity in the payload has been given a unique `id` (according to the NGSI-LD [specification](https://www.etsi.org/deliver/etsi_gs/CIM/001_099/009/01.03.01_60/gs_cim009v010301p.pdf)) and assigned `type=Store`."
					},
					"response": []
				},
				{
					"name": "Create Industrial product",
					"protocolProfileBehavior": {
						"disabledSystemHeaders": {
							"content-type": true
						}
					},
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Auth-token",
								"value": "{{X-Access-token}}",
								"type": "default"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"actionType\": \"APPEND\",\n  \"entities\": [\n    {\n      \"type\": \"IndustrialProduct\",\n      \"id\": \"urn:ngsi-ld:IndustrialProduct:001\",\n      \"name\": {\n          \"type\": \"Text\",\n          \"value\": \"Industrial product name\"\n      }\n    ,\n        \"refFacility\": {\n            \"type\": \"Relationship\",\n            \"value\": \"urn:ngsi-ld:Facility:001\",\n            \"metadata\": {}\n        }\n    }\n  ]\n}"
						},
						"url": {
							"raw": "http://{{orion-proxy}}/v2/op/update",
							"protocol": "http",
							"host": [
								"{{orion-proxy}}"
							],
							"path": [
								"v2",
								"op",
								"update"
							],
							"query": [
								{
									"key": "faciltyId",
									"value": "002",
									"disabled": true
								}
							]
						},
						"description": "This example uses the convenience batch processing endpoint to re-create the two **Store** entities from the previous tutorial.\n\nBatch processing uses the `/v2/op/update` endpoint with a payload with two attributes - `actionType=APPEND` means we will overwrite existing entities if they exist whereas the  `entities` attribute holds an array of entities we wish to update.\n\nAs you can see each **Store** entity in the payload has been given a unique `id` (according to the NGSI-LD [specification](https://www.etsi.org/deliver/etsi_gs/CIM/001_099/009/01.03.01_60/gs_cim009v010301p.pdf)) and assigned `type=Store`."
					},
					"response": []
				},
				{
					"name": "Delete entity",
					"request": {
						"method": "DELETE",
						"header": [
							{
								"key": "X-Auth-token",
								"value": "{{X-Access-token}}",
								"type": "default"
							}
						],
						"url": {
							"raw": "http://{{orion-proxy}}/v2/entities/urn:ngsi-ld:Machine:001",
							"protocol": "http",
							"host": [
								"{{orion-proxy}}"
							],
							"path": [
								"v2",
								"entities",
								"urn:ngsi-ld:Machine:001"
							]
						}
					},
					"response": []
				},
				{
					"name": "List all entities",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "X-Auth-token",
								"value": "{{X-Access-token}}",
								"type": "default"
							}
						],
						"url": {
							"raw": "http://{{orion-proxy}}/v2/entities",
							"protocol": "http",
							"host": [
								"{{orion-proxy}}"
							],
							"path": [
								"v2",
								"entities"
							]
						}
					},
					"response": []
				},
				{
					"name": "List all industrial products",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "X-Auth-token",
								"value": "{{X-Access-token}}",
								"type": "default"
							}
						],
						"url": {
							"raw": "http://{{orion-proxy}}/v2/entities?type=IndustrialProduct",
							"protocol": "http",
							"host": [
								"{{orion-proxy}}"
							],
							"path": [
								"v2",
								"entities"
							],
							"query": [
								{
									"key": "type",
									"value": "IndustrialProduct"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "List all industrial products in a facility",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "X-Auth-token",
								"value": "{{X-Access-token}}",
								"type": "default"
							}
						],
						"url": {
							"raw": "http://{{orion-proxy}}/v2/entities?type=IndustrialProduct&refFacility=urn:ngsi-ld:Facility:001",
							"protocol": "http",
							"host": [
								"{{orion-proxy}}"
							],
							"path": [
								"v2",
								"entities"
							],
							"query": [
								{
									"key": "type",
									"value": "IndustrialProduct"
								},
								{
									"key": "refFacility",
									"value": "urn:ngsi-ld:Facility:001"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "List all entities no metadata",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "X-Auth-token",
								"value": "{{X-Access-token}}",
								"type": "default"
							}
						],
						"url": {
							"raw": "http://{{orion-proxy}}/v2/entities?options=keyValues",
							"protocol": "http",
							"host": [
								"{{orion-proxy}}"
							],
							"path": [
								"v2",
								"entities"
							],
							"query": [
								{
									"key": "options",
									"value": "keyValues"
								}
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Connecting IoT Devices",
			"item": [
				{
					"name": "IoT Agent - Create a Service Group",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n \"services\": [\n   {\n     \"apikey\":      \"4jggokgpepnvsb2uv4s40d59o1\",\n     \"cbroker\":     \"http://orion:1027\",\n     \"entity_type\": \"PressureSensor\",\n     \"resource\":    \"/iot/json\",\n     \"trust\" : \"32b550e134036be2a304c2b3a8b1c7d580a1f950\"\n   }\n ]\n}"
						},
						"url": {
							"raw": "http://{{iot-agent}}/iot/services",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"services"
							]
						},
						"description": "Invoking group provision is always the the first step in connecting devices since it is always necessary to\nsupply an authentication key with each measurement and the IoT Agent will not initially know which URL \nthe context broker is responding on.\n\nIt is possible to set up default commands and attributes for all devices as well, but this\nis not done within this tutorial as we will be provisioning each device separately.\n\nThis example provisions an anonymous group of devices. It tells the IoT Agent that a series of devices\nwill be sending messages to the `IOTA_HTTP_PORT` (where the IoT Agent is listening for **Northbound** communications)\n\nIn the example the IoT Agent is informed that the `/iot/d` endpoint will be used and that devices will authenticate\nthemselves by including the token `4jggokgpepnvsb2uv4s40d59ov`. For an UltraLight IoT Agent this means devices will\nbe sending GET or POST requests to: \n\n```\nhttp://iot-agent:7896/iot/d?i=<device_id>&k=4jggokgpepnvsb2uv4s40d59ov\n```\n\nWhich should be familiar UltraLight 2.0 syntax from the previous tutorial.\n\nWhen a measurement from an IoT device is received on the resource url it needs to be \ninterpreted and passed to the context broker. The `entity_type` attribute provides a\ndefault `type` for each device which has made a  request (in this case anonymous devices\nwill be known as `Thing` entities. Furthermore the location of the\ncontext broker (`cbroker`) is needed, so that the IoT Agent can pass on any measurements \nreceived to the  correct URL. `cbroker` is an optional attribute - if it is not provided, \nthe IoT Agent uses the context broker URL as defined in the configuration file, however\nit has been included here for completeness."
					},
					"response": []
				},
				{
					"name": "IoT Agent - List service groups",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "http://{{iot-agent}}/iot/services",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"services"
							]
						},
						"description": "Invoking group provision is always the the first step in connecting devices since it is always necessary to\nsupply an authentication key with each measurement and the IoT Agent will not initially know which URL \nthe context broker is responding on.\n\nIt is possible to set up default commands and attributes for all devices as well, but this\nis not done within this tutorial as we will be provisioning each device separately.\n\nThis example provisions an anonymous group of devices. It tells the IoT Agent that a series of devices\nwill be sending messages to the `IOTA_HTTP_PORT` (where the IoT Agent is listening for **Northbound** communications)\n\nIn the example the IoT Agent is informed that the `/iot/d` endpoint will be used and that devices will authenticate\nthemselves by including the token `4jggokgpepnvsb2uv4s40d59ov`. For an UltraLight IoT Agent this means devices will\nbe sending GET or POST requests to: \n\n```\nhttp://iot-agent:7896/iot/d?i=<device_id>&k=4jggokgpepnvsb2uv4s40d59ov\n```\n\nWhich should be familiar UltraLight 2.0 syntax from the previous tutorial.\n\nWhen a measurement from an IoT device is received on the resource url it needs to be \ninterpreted and passed to the context broker. The `entity_type` attribute provides a\ndefault `type` for each device which has made a  request (in this case anonymous devices\nwill be known as `Thing` entities. Furthermore the location of the\ncontext broker (`cbroker`) is needed, so that the IoT Agent can pass on any measurements \nreceived to the  correct URL. `cbroker` is an optional attribute - if it is not provided, \nthe IoT Agent uses the context broker URL as defined in the configuration file, however\nit has been included here for completeness."
					},
					"response": []
				},
				{
					"name": "IoT Agent - Delete service group",
					"request": {
						"method": "DELETE",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "http://{{iot-agent}}/iot/services/?resource=/iot/json&apikey=4jggokgpepnvsb2uv4s40d59o1",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"services",
								""
							],
							"query": [
								{
									"key": "resource",
									"value": "/iot/json"
								},
								{
									"key": "apikey",
									"value": "4jggokgpepnvsb2uv4s40d59o1"
								}
							]
						},
						"description": "Invoking group provision is always the the first step in connecting devices since it is always necessary to\nsupply an authentication key with each measurement and the IoT Agent will not initially know which URL \nthe context broker is responding on.\n\nIt is possible to set up default commands and attributes for all devices as well, but this\nis not done within this tutorial as we will be provisioning each device separately.\n\nThis example provisions an anonymous group of devices. It tells the IoT Agent that a series of devices\nwill be sending messages to the `IOTA_HTTP_PORT` (where the IoT Agent is listening for **Northbound** communications)\n\nIn the example the IoT Agent is informed that the `/iot/d` endpoint will be used and that devices will authenticate\nthemselves by including the token `4jggokgpepnvsb2uv4s40d59ov`. For an UltraLight IoT Agent this means devices will\nbe sending GET or POST requests to: \n\n```\nhttp://iot-agent:7896/iot/d?i=<device_id>&k=4jggokgpepnvsb2uv4s40d59ov\n```\n\nWhich should be familiar UltraLight 2.0 syntax from the previous tutorial.\n\nWhen a measurement from an IoT device is received on the resource url it needs to be \ninterpreted and passed to the context broker. The `entity_type` attribute provides a\ndefault `type` for each device which has made a  request (in this case anonymous devices\nwill be known as `Thing` entities. Furthermore the location of the\ncontext broker (`cbroker`) is needed, so that the IoT Agent can pass on any measurements \nreceived to the  correct URL. `cbroker` is an optional attribute - if it is not provided, \nthe IoT Agent uses the context broker URL as defined in the configuration file, however\nit has been included here for completeness."
					},
					"response": []
				},
				{
					"name": "IoT Agent - Create a pressure Sensor",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Auth-token",
								"value": "{{X-Access-token}}",
								"type": "default"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n \"devices\": [\n   {\n     \"device_id\":   \"pressure001\",\n     \"entity_name\": \"urn:ngsi-ld:Pressure:001\",\n     \"entity_type\": \"PressureSensor\",\n     \"protocol\": \"IoTA-JSON\",\n     \"transport\":   \"MQTT\",\n     \"timezone\":    \"Europe/Berlin\",\n     \"attributes\": [\n       { \"object_id\": \"p\", \"name\":\"pressure\", \"type\":\"Double\"}\n      ],\n      \"static_attributes\": [\n         {\"name\":\"refIndustrialProduct\", \"type\": \"Relationship\",\"value\": \"urn:ngsi-ld:IndustrialProduct:001\"}\n      ]\n   }\n ]\n}\n"
						},
						"url": {
							"raw": "http://{{iot-agent}}/iot/devices",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"devices"
							]
						},
						"description": "It is common good practice to use URNs following the NGSI-LD [specification](https://www.etsi.org/deliver/etsi_gs/CIM/001_099/009/01.03.01_60/gs_cim009v010301p.pdf) when creating entities. Furthermore it is easier to understand\nmeaningful names when defining data attributes. These mappings can be defined by provisioning a device individually.\n\nThree types of meaasurement attributes can be provisioned:\n\n* `attributes` are active readings from the device\n* `lazy` attributes are only sent on request -  The IoT Agent will inform the device to return the measurement\n* `static_attributes` are as the name suggests static data about the device (such as relationships) passed on \n  to the context broker.\n\n>**Note**: in the case where individual `id`s are not required, or aggregated data is sufficient \n> the `attributes` can be defined within the provisioning service rather than individually.\n\nIn the request we are assiociating the device `motion001` with the URN `urn:ngsi-ld:Motion:001`\nand mapping the device reading `c` with the context attribute `count` (which is defined as an `Integer`)\nA `refStore` is defined as a `static_attribute`, placing the device within **Store** `urn:ngsi-ld:Store:001`"
					},
					"response": []
				},
				{
					"name": "Dummy Device  - Mesurement",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "X-Auth-token",
								"value": "{{X-Access-token}}",
								"type": "default"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\"p\":\"102\"}"
						},
						"url": {
							"raw": "http://{{iot-agent-north}}/iot/json?k=4jggokgpepnvsb2uv4s40d59o1&i=pressure001",
							"protocol": "http",
							"host": [
								"{{iot-agent-north}}"
							],
							"path": [
								"iot",
								"json"
							],
							"query": [
								{
									"key": "k",
									"value": "4jggokgpepnvsb2uv4s40d59o1"
								},
								{
									"key": "i",
									"value": "pressure001"
								}
							]
						},
						"description": "This example simulates a request coming from the device `motion001`\n\nThe request to the previously provisioned resource `iot/d` is in UltraLight 2.0 format\nand identifies the device `motion001` and passes a known API key.\n\nA similar request was made in the previous tutorial (before the IoT Agent was connected)\nwhen the door was unlocked, you will have seen the state of each motion sensor changing\nand a Northbound request will be logged in the device monitor."
					},
					"response": []
				},
				{
					"name": "IoT Agent - List all Provisioned Devices",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							}
						],
						"url": {
							"raw": "http://{{iot-agent}}/iot/devices",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"devices"
							]
						},
						"description": "This example lists all provisioned devices by making a GET request to the `/iot/devices` endpoint.\n\nThe response includes all the commands and attributes mappings associated with all provisioned IoT devices."
					},
					"response": []
				},
				{
					"name": "Context Broker - Read pressure sensor",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							},
							{
								"key": "X-Auth-token",
								"value": "{{X-Access-token}}",
								"type": "default"
							}
						],
						"url": {
							"raw": "http://{{orion-proxy}}/v2/entities/urn:ngsi-ld:Pressure:001",
							"protocol": "http",
							"host": [
								"{{orion-proxy}}"
							],
							"path": [
								"v2",
								"entities",
								"urn:ngsi-ld:Pressure:001"
							]
						},
						"description": "This example returns the data for the `Motion` entity with the `id=urn:ngsi-ld:Motion:001` within the context data.\n\nThe response shows that the device with `id=motion001` has been successfully identifed by the IoT Agent and mapped to the\nentity `id=urn:ngsi-ld:Motion:001`. This new entity has been created within the context data. The `c` \nattribute from the dummy device measurement request has been mapped to the more meaningful `count` attribute\nwithin the context. As you will notice, a `TimeInstant` attribute has been added to both the entity and the\nmeta data of the attribute - this represents the last time the entity and attribute have been updated, and is\nautomatically added to each new entity because the `IOTA_TIMESTAMP`  environment variable was set when the\nIoT Agent was started up. The `refStore` attribute comes from the `static_attributes` set when the device was provisioned."
					},
					"response": []
				},
				{
					"name": "Context Broker - Read pressure sensor by industrial product",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							},
							{
								"key": "X-Auth-token",
								"value": "{{X-Access-token}}",
								"type": "default"
							}
						],
						"url": {
							"raw": "http://{{orion-proxy}}/v2/entities/?refIndustrialProduct=urn:ngsi-ld:IndustrialProduct:001",
							"protocol": "http",
							"host": [
								"{{orion-proxy}}"
							],
							"path": [
								"v2",
								"entities",
								""
							],
							"query": [
								{
									"key": "refIndustrialProduct",
									"value": "urn:ngsi-ld:IndustrialProduct:001"
								},
								{
									"key": "X-Auth-token",
									"value": "{{X-Access-token}}",
									"disabled": true
								}
							]
						},
						"description": "This example returns the data for the `Motion` entity with the `id=urn:ngsi-ld:Motion:001` within the context data.\n\nThe response shows that the device with `id=motion001` has been successfully identifed by the IoT Agent and mapped to the\nentity `id=urn:ngsi-ld:Motion:001`. This new entity has been created within the context data. The `c` \nattribute from the dummy device measurement request has been mapped to the more meaningful `count` attribute\nwithin the context. As you will notice, a `TimeInstant` attribute has been added to both the entity and the\nmeta data of the attribute - this represents the last time the entity and attribute have been updated, and is\nautomatically added to each new entity because the `IOTA_TIMESTAMP`  environment variable was set when the\nIoT Agent was started up. The `refStore` attribute comes from the `static_attributes` set when the device was provisioned."
					},
					"response": []
				},
				{
					"name": "IoT Agent - Delete device",
					"request": {
						"method": "DELETE",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							}
						],
						"url": {
							"raw": "http://{{iot-agent}}/iot/devices/pressure001",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"devices",
								"pressure001"
							]
						},
						"description": "This example lists all provisioned devices by making a GET request to the `/iot/devices` endpoint.\n\nThe response includes all the commands and attributes mappings associated with all provisioned IoT devices."
					},
					"response": []
				}
			],
			"description": "The IoT Agent acts as a middleware between the IoT devices and the context broker. It therefore\nneeds to be able to create context data entities with unique ids.  Once a service has been provisioned\nand an unknown device makes a measurement the IoT Agent add this to the context using the supplied\n`<device-id>` (unless the device is recognized and can be mapped to a known id.\n\nThere is no guarantee that every supplied IoT device `<device-id>` will always be unique, therefore \nall provisioning requests to the IoT Agent require two mandatory headers:\n\n* `fiware-service` header is defined so that entities for a given service can be held in a separate mongoDB database.\n* `fiware-servicepath` can be used to differenciate between arrays of devices. \n\nFor example within a smart city application you would expect different `fiware-service` headers for different\ndepartments (e.g. parks, transport, refuse collection etc.) and each `fiware-servicepath`  would refer to specific park \nand so on. This would mean that data and devices for each service can be identified and separated as needed, but the\ndata would not be siloed - for example data from a  **Smart Bin** within a park can be combined with the **GPS Unit** \nof a refuse truck to alter the route of the truck in an efficient manner. \n\nThe **Smart Bin** and **GPS Unit** are likely to come from different manufacturers and it cannot be \nguaranteed that that there is no overlap within `<device-ids>`s used. The use of the  `fiware-service` and\n`fiware-servicepath` headers can ensure that this is always the case, and allows the context broker to identify\nthe original source of the context data.\n",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "Setting up Subscriptions",
			"item": [
				{
					"name": "Orion - QuantumLeap - Aggregate Pressure sensor value",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"description\": \"Notify QuantumLeap of all pressure sensore changes\",\n  \"subject\": {\n    \"entities\": [\n      {\n        \"idPattern\": \"urn:ngsi-ld:Pressure:001\"\n      }\n    ],\n    \"condition\": {\n      \"attrs\": [\n        \"pressure\"\n      ]\n    }\n  },\n  \"notification\": {\n    \"http\": {\n      \"url\": \"http://quantumleap:8668/v2/notify\"\n    },\n    \"attrs\": [\n      \"pressure\"\n    ],\n    \"metadata\": [\"dateCreated\", \"dateModified\"]\n  }\n}"
						},
						"url": {
							"raw": "http://{{orion}}/v2/subscriptions/",
							"protocol": "http",
							"host": [
								"{{orion}}"
							],
							"path": [
								"v2",
								"subscriptions",
								""
							]
						},
						"description": "The rate of change of the **Motion Sensor** is driven by events in the real-world. We need to receive\nevery event to be able to aggregate the results.\n\nThis is done by making a POST request to the `/v2/subscription` endpoint of the Orion Context Broker.\n\n* The `fiware-service` and `fiware-servicepath` headers are used to filter the subscription to only listen to measurements from the attached IoT Sensors\n* The `idPattern` in the request body ensures that **Quantum Leap** will be informed of all **Motion Sensor** data changes.\n* The notification `url` must match the exposed port.\n\nThe `metadata` attribute ensures that the `time_index` column within the Crate-DB database will match the data found within the **Orion Context Broker** rather than using the creation time of the record within the Crate-DB itself."
					},
					"response": []
				},
				{
					"name": "Orion - Check Subscriptions",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							},
							{
								"key": "X-Auth-token",
								"value": "{{X-Access-token}}",
								"type": "default"
							}
						],
						"url": {
							"raw": "http://{{orion-proxy}}/v2/subscriptions/",
							"protocol": "http",
							"host": [
								"{{orion-proxy}}"
							],
							"path": [
								"v2",
								"subscriptions",
								""
							]
						},
						"description": "If the subscriptions have been created, you can check to see if they are firing by making a GET \nrequest to the `/v2/subscriptions` endpoint.\n\nWithin the `notification` section of the response, you can see several additional `attributes` which describe the health of the subscription\n\nIf the criteria of the subscription have been met, `timesSent` should be greater than `0`.\nA zero value would indicate that the `subject` of the subscription is incorrect or the subscription \nhas created with the wrong `fiware-service-path` or `fiware-service` header\n\nThe `lastNotification` should be a recent timestamp - if this is not the case, then the devices\nare not regularly sending data. Remember to unlock the **Smart Door** and switch on the **Smart Lamp**\n\nThe `lastSuccess` should match the `lastNotification` date - if this is not the case \nthen **Quantum Leap** is not receiving the subscription properly. Check that the host name\nand port are correct. \n\nFinally, check that the `status` of the subscription is `active` - an expired subscription\nwill not fire."
					},
					"response": []
				},
				{
					"name": "Orion - Delete Subscription",
					"request": {
						"method": "DELETE",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							},
							{
								"key": "X-Auth-token",
								"value": "{{X-Access-token}}",
								"type": "default"
							}
						],
						"url": {
							"raw": "http://{{orion-proxy}}/v2/subscriptions/633daac4c5d5bd60cc820580",
							"protocol": "http",
							"host": [
								"{{orion-proxy}}"
							],
							"path": [
								"v2",
								"subscriptions",
								"633daac4c5d5bd60cc820580"
							]
						},
						"description": "If the subscriptions have been created, you can check to see if they are firing by making a GET \nrequest to the `/v2/subscriptions` endpoint.\n\nWithin the `notification` section of the response, you can see several additional `attributes` which describe the health of the subscription\n\nIf the criteria of the subscription have been met, `timesSent` should be greater than `0`.\nA zero value would indicate that the `subject` of the subscription is incorrect or the subscription \nhas created with the wrong `fiware-service-path` or `fiware-service` header\n\nThe `lastNotification` should be a recent timestamp - if this is not the case, then the devices\nare not regularly sending data. Remember to unlock the **Smart Door** and switch on the **Smart Lamp**\n\nThe `lastSuccess` should match the `lastNotification` date - if this is not the case \nthen **Quantum Leap** is not receiving the subscription properly. Check that the host name\nand port are correct. \n\nFinally, check that the `status` of the subscription is `active` - an expired subscription\nwill not fire."
					},
					"response": []
				}
			],
			"description": "Once a dynamic context system is up and running, we need to inform **Quantum\nLeap** directly of changes in context. As expected this is done using the\nsubscription mechanism of the **Orion Context Broker**. The `attrsFormat=legacy`\nattribute is not required since **QuantumLeap** accepts NGSI v2 notifications\ndirectly.\n\nSubscriptions will be covered in the next subsections. More details about\nsubscriptions can be found in previous tutorials or in the\n[subscriptions section](https://quantumleap.readthedocs.io/en/latest/user/#orion-subscription)\nof QuantumLeap docs.",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "Time Series Data Queries",
			"item": [
				{
					"name": "QuantumLeap - Obtain version information",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "http://{{quantumleap}}/version",
							"protocol": "http",
							"host": [
								"{{quantumleap}}"
							],
							"path": [
								"version"
							]
						}
					},
					"response": []
				},
				{
					"name": "List the first N Pressure Sampled Values",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							},
							{
								"key": "Fiware-Service",
								"value": "openiot",
								"type": "text"
							},
							{
								"key": "Fiware-ServicePath",
								"value": "/",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "http://{{quantumleap}}/v2/entities/urn:ngsi-ld:Pressure:001",
							"protocol": "http",
							"host": [
								"{{quantumleap}}"
							],
							"path": [
								"v2",
								"entities",
								"urn:ngsi-ld:Pressure:001"
							]
						},
						"description": "This example shows the first 3 sampled `luminosity` values from `Lamp:001`. \n\nNote the use of `Fiware-Service` and `Fiware-ServicePath` headers. These are\nrequired only when data are pushed to orion using such headers (in multitenancy\nscenarios). Failing to align these headers will result in no data being\nreturned."
					},
					"response": []
				},
				{
					"name": "List N Sampled Values at an Offset",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							},
							{
								"key": "Fiware-Service",
								"value": "openiot",
								"type": "text"
							},
							{
								"key": "Fiware-ServicePath",
								"value": "/",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "http://{{quantumleap}}/v2/entities/Motion:001/attrs/count?offset=3&limit=3",
							"protocol": "http",
							"host": [
								"{{quantumleap}}"
							],
							"path": [
								"v2",
								"entities",
								"Motion:001",
								"attrs",
								"count"
							],
							"query": [
								{
									"key": "offset",
									"value": "3"
								},
								{
									"key": "limit",
									"value": "3"
								}
							]
						},
						"description": "This example shows the fourth, fifth and sixth sampled count values from Motion:001.\n"
					},
					"response": []
				},
				{
					"name": "List the latest N Sampled Values",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							},
							{
								"key": "Fiware-Service",
								"value": "openiot",
								"type": "text"
							},
							{
								"key": "Fiware-ServicePath",
								"value": "/",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "http://{{quantumleap}}/v2/entities/urn:ngsi-ld:Pressure:001/attrs/pressure?lastN=3",
							"protocol": "http",
							"host": [
								"{{quantumleap}}"
							],
							"path": [
								"v2",
								"entities",
								"urn:ngsi-ld:Pressure:001",
								"attrs",
								"pressure"
							],
							"query": [
								{
									"key": "lastN",
									"value": "3"
								}
							]
						},
						"description": "This example shows latest three sampled `count` values from `Motion:001`."
					},
					"response": []
				},
				{
					"name": "List the Sum of values over a time period",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							},
							{
								"key": "Fiware-Service",
								"value": "openiot",
								"type": "text"
							},
							{
								"key": "Fiware-ServicePath",
								"value": "/",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "http://{{quantumleap}}/v2/entities/Motion:001/attrs/count?aggrMethod=count&aggrPeriod=minute&lastN=3",
							"protocol": "http",
							"host": [
								"{{quantumleap}}"
							],
							"path": [
								"v2",
								"entities",
								"Motion:001",
								"attrs",
								"count"
							],
							"query": [
								{
									"key": "aggrMethod",
									"value": "count"
								},
								{
									"key": "aggrPeriod",
									"value": "minute"
								},
								{
									"key": "lastN",
									"value": "3"
								}
							]
						},
						"description": "This example shows total `count` values from `Motion:001` over each minute.\n\nYou need QuantumLeap **version >= 0.4.1**. You can check your version with a\nsimple GET like:\n\n```\ncurl -X GET \\\n  'http://localhost:8668/v2/version' \\\n  -H 'Accept: application/json'\n```"
					},
					"response": []
				},
				{
					"name": "List the Minimum Values over a Time Period",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							},
							{
								"key": "Fiware-Service",
								"value": "openiot",
								"type": "text"
							},
							{
								"key": "Fiware-ServicePath",
								"value": "/",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "http://{{quantumleap}}/v2/entities/Lamp:001/attrs/luminosity?aggrMethod=min&aggrPeriod=minute&lastN=3",
							"protocol": "http",
							"host": [
								"{{quantumleap}}"
							],
							"path": [
								"v2",
								"entities",
								"Lamp:001",
								"attrs",
								"luminosity"
							],
							"query": [
								{
									"key": "aggrMethod",
									"value": "min"
								},
								{
									"key": "aggrPeriod",
									"value": "minute"
								},
								{
									"key": "lastN",
									"value": "3"
								}
							]
						},
						"description": "This example shows minimum `luminosity` values from `Lamp:001` over each minute.\n\nYou need QuantumLeap **version >= 0.4.1**. You can check your version with a\nsimple GET like:\n\n```console\ncurl -X GET \\\n  'http://localhost:8668/v2/version' \\\n  -H 'Accept: application/json'\n```"
					},
					"response": []
				},
				{
					"name": "List the Maximum Values over a Time Period",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "Fiware-Service",
								"value": "openiot",
								"type": "text"
							},
							{
								"key": "Fiware-ServicePath",
								"value": "/",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "http://{{quantumleap}}/v2/entities/Lamp:001/attrs/luminosity?aggrMethod=max&fromDate=2018-06-27T09:00:00&toDate=2018-06-30T23:59:59",
							"protocol": "http",
							"host": [
								"{{quantumleap}}"
							],
							"path": [
								"v2",
								"entities",
								"Lamp:001",
								"attrs",
								"luminosity"
							],
							"query": [
								{
									"key": "aggrMethod",
									"value": "max"
								},
								{
									"key": "fromDate",
									"value": "2018-06-27T09:00:00"
								},
								{
									"key": "toDate",
									"value": "2018-06-30T23:59:59"
								}
							]
						},
						"description": "This example shows maximum `luminosity` value of `Lamp:001` that occurred\nbetween from `2018-06-27T09:00:00` to `2018-06-30T23:59:59`.\n\nAlter the `fromDate` and `toDate` parameters to retrieve your current data"
					},
					"response": []
				},
				{
					"name": "List the latest N Sampled Values of Devices near a Point",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "Fiware-Service",
								"type": "text",
								"value": "openiot"
							},
							{
								"key": "Fiware-ServicePath",
								"type": "text",
								"value": "/"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "http://{{quantumleap}}/v2/types/Lamp/attrs/luminosity?lastN=4&georel=near;maxDistance:5000&geometry=point&coords=52.5547,13.3986\n",
							"protocol": "http",
							"host": [
								"{{quantumleap}}"
							],
							"path": [
								"v2",
								"types",
								"Lamp",
								"attrs",
								"luminosity"
							],
							"query": [
								{
									"key": "lastN",
									"value": "4"
								},
								{
									"key": "georel",
									"value": "near;maxDistance:5000"
								},
								{
									"key": "geometry",
									"value": "point"
								},
								{
									"key": "coords",
									"value": "52.5547,13.3986\n"
								}
							]
						},
						"description": "This example shows the latest four sampled `luminosity` values of lamps that\nare within a 5 km radius from `52°33'16.9\"N 13°23'55.0\"E` (Bornholmer Straße\n65, Berlin, Germany). If you have turned on all the lamps available on the\ndevice monitor page, you should be able to see data for `Lamp:001` and\n`Lamp:004`.\n\n> **Note:** Geographical queries are only available\n> starting from version `0.5` of QuantumLeap which implements the full\n> set of queries detailed in the Geographical Queries section of the\n> [NGSI v2 specification](http://fiware.github.io/specifications/ngsiv2/stable/)."
					},
					"response": []
				},
				{
					"name": "List the latest N Sampled Values of Devices in an Area",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "Fiware-Service",
								"type": "text",
								"value": "openiot"
							},
							{
								"key": "Fiware-ServicePath",
								"type": "text",
								"value": "/"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "http://{{quantumleap}}/v2/types/Lamp/attrs/luminosity?lastN=4&georel=coveredBy&geometry=polygon&coords=52.5537,13.3996;52.5557,13.3996;52.5557,13.3976;52.5537,13.3976;52.5537,13.3996",
							"protocol": "http",
							"host": [
								"{{quantumleap}}"
							],
							"path": [
								"v2",
								"types",
								"Lamp",
								"attrs",
								"luminosity"
							],
							"query": [
								{
									"key": "lastN",
									"value": "4"
								},
								{
									"key": "georel",
									"value": "coveredBy"
								},
								{
									"key": "geometry",
									"value": "polygon"
								},
								{
									"key": "coords",
									"value": "52.5537,13.3996;52.5557,13.3996;52.5557,13.3976;52.5537,13.3976;52.5537,13.3996"
								}
							]
						},
						"description": "This example shows the latest four sampled `luminosity` values of lamps that\nare inside a square of side 200 m centred at `52°33'16.9\"N 13°23'55.0\"E`\n(Bornholmer Straße 65, Berlin, Germany). Even if you have turned on all the\nlamps available on the device monitor page, you should only see data for\n`Lamp:001`.\n\n> **Note:** Geographical queries are only available\n> starting from version `0.5` of QuantumLeap which implements the full\n> set of queries detailed in the Geographical Queries section of the\n> [NGSI v2 specification](http://fiware.github.io/specifications/ngsiv2/stable/)."
					},
					"response": []
				}
			],
			"description": "**CrateDB** offers an\n[HTTP Endpoint](https://crate.io/docs/crate/reference/en/latest/interfaces/http.html)\nthat can be used to submit SQL queries. The endpoint is accessible under\n`<servername:port>/_sql`.\n\nSQL statements are sent as the body of POST requests in JSON format, where the\nSQL statement is the value of the `stmt` attribute.\n\n> When to query **CrateDB** and when **QuantumLeap**?. As a rule of thumb,\n> prefer working always with **QuantumLeap** for the following reasons:\n>\n> -   Your experience will be closer to FIWARE NGSI APIs like Orion's.\n> -   Your application will not be tied to CrateDB's specifics nor QuantumLeap's\n>     implementation details, which could change and break your app.\n> -   QuantumLeap can be easily extended to other backends and your app will get\n>     compatibility for free.\n> -   If your deployment is distributed, you won't need to expose the ports of\n>     your database to the outside.\n\nIf your are sure your query is not supported by **QuantumLeap**, you may have to\nend up querying **CrateDB**, however, please open an issue in\n[QuantumLeap's repo](https://github.com/smartsdk/ngsi-timeseries-api/issues) so\nthe team is aware.\n",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "iot-agent",
			"value": "localhost:4041",
			"type": "string"
		},
		{
			"key": "orion",
			"value": "localhost:1026",
			"type": "string"
		},
		{
			"key": "ultralight",
			"value": "localhost:3001",
			"type": "string"
		},
		{
			"key": "keyrock",
			"value": "localhost:3005",
			"type": "default"
		},
		{
			"key": "X-Auth-token",
			"value": "a4f0be68-7f44-44c2-9730-c91043bb2361",
			"type": "default"
		},
		{
			"key": "application-id",
			"value": "c8369695-6a8f-4f5c-ba4d-2c946d4ee9ea",
			"type": "default"
		},
		{
			"key": "orion-proxy",
			"value": "localhost:1027",
			"type": "default"
		},
		{
			"key": "X-Access-token",
			"value": "5cc29fe54fa0e35693036ac17ae8667a9d50c95b",
			"type": "default"
		},
		{
			"key": "Authorization",
			"value": "YzgzNjk2OTUtNmE4Zi00ZjVjLWJhNGQtMmM5NDZkNGVlOWVhOjY2YjUxYWJkLWE3M2EtNDU0YS1hN2Y2LWY0MDI1MjMxMzg1Mg==",
			"type": "default"
		},
		{
			"key": "quantumleap",
			"value": "localhost:8668",
			"type": "default"
		},
		{
			"key": "iot-agent-north",
			"value": "localhost:7896",
			"type": "default"
		}
	]
}